// Minimal production-safe service worker
// - Caches only the app shell and static build assets under /assets/
// - Network-first for navigation requests with fallback to cached index.html
// - Cache-first for static assets (no advanced strategies)
// - Single cache name, intentionally minimal for stability

const CACHE_NAME = 'static-assets-v2';

// Do not precache index.html or app shell. This service worker only caches
// build-generated static assets under /assets/ to improve performance.
self.addEventListener('install', (event) => {
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  // On activation, clear any existing caches so clients will fetch
  // the latest build assets instead of receiving stale cached files.
  event.waitUntil(
    caches.keys().then((keys) => Promise.all(keys.map((k) => caches.delete(k)))).then(() => self.clients.claim())
  );
});

// Helper: isSameOriginStaticAsset
function isStaticAsset(request) {
  try {
    const url = new URL(request.url);
    return url.origin === self.location.origin && url.pathname.startsWith('/assets/');
  } catch (e) {
    return false;
  }
}

self.addEventListener('fetch', (event) => {
  const { request } = event;

  // Navigation requests: use network-first by forwarding to the network.
  // Do NOT provide an offline fallback here — allow the browser to show its
  // default offline/error page when the network is unavailable. This keeps
  // behavior stable and avoids partial/white-screen renders.
  const acceptsHTML = request.headers && request.headers.get && request.headers.get('accept') && request.headers.get('accept').includes('text/html');
  if (request.mode === 'navigate' || (request.method === 'GET' && acceptsHTML)) {
    // Forward navigation requests to network — no try/catch fallback.
    event.respondWith(fetch(request));
    return;
  }

  // Static assets generated by the build: cache-first (only under /assets/)
  if (isStaticAsset(request) || request.destination === 'style' || request.destination === 'script') {
    // Do not serve cached static assets; always forward to network so updated
    // bundles are returned after cache purge. We still attempt to populate the
    // cache for future navigations, but activation clears old caches.
    event.respondWith(
      fetch(request).then((resp) => {
        try {
          const copy = resp.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(request, copy)).catch(() => {});
        } catch (e) {}
        return resp;
      }).catch(() => caches.match(request))
    );
    return;
  }

  // For everything else (APIs, dynamic data), do not interfere — let the network handle it
});
